<?php

include_once('drush/drush.inc');
include_once('includes/OsSearchApiSolrService.php');

function os_search_ctools_plugin_api($module, $api) {
  if ($module == 'boxes' && $api == 'box') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_default_search_api_server().
 */
function os_search_default_search_api_server() {
  $items = array();

  $items['solr_server'] = entity_import('search_api_server', '{
    "name" : "Solr Server",
    "machine_name" : "solr_server",
    "description" : "",
    "class" : "search_api_solr_service",
    "options" : {
      "http_user" : "",
      "http_pass" : "",
      "excerpt" : 0,
      "retrieve_data" : 0,
      "highlight_data" : 0,
      "name" : "Solr Server",
      "description" : "",
      "host" : "localhost",
      "port" : "8983",
      "path" : "solr"
    },
    "enabled" : "1",
    "rdf_mapping" : []
  }');

  return $items;
}

function os_search_search_api_item_type_info_alter(array &$infos) {
  // Adds a boolean value is_entity to all type options telling whether the item
  // type represents an entity type.
  foreach ($infos as $type => $info) {
    $info['is_entity'] = (bool) entity_get_info($type);
  }
}

/**
 * Implements hook_default_search_api_index().
 */
function os_search_default_search_api_index() {
  $items = array();
  $items['site_search'] = entity_import('search_api_index', '{
    "name" : "Site search",
    "machine_name" : "site_search",
    "description" : "Index for nodes used by the OpenScholar sites.",
    "server" : "solr_server",
    "item_type" : "node",
    "options" : {
      "index_directly" : 1,
      "cron_limit" : "50",
      "fields" : {
        "type" : { "type" : "string" },
        "title": { "type" : "string" }
      },
      "processors" : {
        "search_api_tokenizer" : {
          "status" : 1,
          "weight" : "20",
          "settings" : {
            "fields" : { "title" : true },
            "spaces" : "[^\\\\p{L}\\\\p{N}]",
            "ignorable" : ""
          }
        }
      }
    },
    "enabled" : "1",
    "read_only" : "1",
    "rdf_mapping" : []
  }');
  return $items;
}


/**
 * Implements hook_boxes_plugins().
 */
function os_search_boxes_plugins() {
  $plugins = array();

  $plugins['os_search_search_box'] = array(
    'title' => t('Filtered search'),
    'tags' => array('Content'),
    'handler' => array(
      'class' => 'os_search_search_box',
      'file' => 'os_search_search_box.inc',
      'path' => drupal_get_path('module', 'os_search') . '/plugins/os_search_search_box',
      'parent' => 'os_boxes_default',
    ),
  );

  return $plugins;
}


/**
 * Implements hook_block_info().
 */
function os_search_block_info() {
  $blocks = array();

  $blocks['site-search'] = array(
    'info' => t('Site Search'),
    'weight' => '10',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * Generate a block with a promotional link to openscholar.harvard.edu and
 * all os menu blocks.
 */
function os_search_block_view($delta = '') {
  if ($delta != 'site-search') {
    return array();
  }

  $block = array();
  $block['subject'] = NULL;
  $block['content'] = drupal_get_form('search_block_form');
  return $block;
}

/**
* Implements hook_views_api().
*
* Enabling using templates inside module
*/
function os_search_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'os_search'),
    'template path' => drupal_get_path('module', 'os_search') . '/templates'
  );
}

function os_search_search_api_service_info_alter(array &$service_info) {
  $service_info['search_api_solr_service']['class'] = 'OsSearchApiSolrService';
}

/**
 * Implements hook_ctools_plugin_pre_alter().
 *
 * Use OS's Facet API adapter.
 */
function os_search_solr_ctools_plugin_pre_alter(&$plugin, &$info) {
  if ($plugin['name'] != 'apachesolr' || $plugin['plugin type'] != 'adapters') {
    return;
  }

  $plugin['handler']['class'] = 'OsApacheSolrFacetapiAdapter';
}

/**
 * Implements hook_form_alter()
 */
function os_search_form_alter(&$form, &$form_state, $form_id) {
  // Override the Apache Solr Search Page configuration form.
  if ($form_id == 'apachesolr_search_page_settings_form') {
    $view_modes = array('' => t('Use default core search result'));
    $entity_info = entity_get_info('node');

    // Build the view modes dropdown list
    foreach ($entity_info['view modes'] as $machine_name => $view_mode) {
      $view_modes[$machine_name] = $view_mode['label'];
    }

    // Override form to add custom view modes dropdown.
    if ($view_modes) {
      // Grab search page id
      $search_page_id = $form['search_page']['#value']['page_id'];

      // Fetch currently save Solr view modes.
      $solr_view_modes = variable_get('os_search_display_mode', '');
      $form['info']['page_title']['#weight'] = -2;
      $form['info']['solr_search_view_mode'] = array(
        '#type' => 'select',
        '#title' => t('View Mode'),
        '#description' => t('Select another view mode in favor of the default search view mode.'),
        '#options' => $view_modes,
        '#weight' => -1,
        '#default_value' => isset($solr_view_modes[$search_page_id]) ? $solr_view_modes[$search_page_id] : '',
      );

      // Add custom submit handler
      $form['#submit'][] = 'os_search_save_view_mode_from_form';
    }
  }
}

/**
 * Apache Solr Save View Mode Form Submit Handler
 */
function os_search_save_view_mode_from_form($form, &$form_state) {
  $values = $form_state['values'];
  os_search_save_view_mode($values['page_id'], $values['solr_search_view_mode']);
}

/**
 * Set the view mode for the given page id for current vsite or globally.
 *
 * @param $page_id
 *   Page id as defined for the Solr pages.
 * @param $view_mode
 *   View mode name.
 */
function os_search_save_view_mode($page_id, $view_mode) {
  // Get Solr View Modes
  $solr_view_modes = variable_get('os_search_display_mode', array());

  // Save Apache Solr View Modes. Use VSite if exists.
  if (module_exists('vsite') && $vsite = vsite_get_vsite()) {
    // Set View Mode
    $solr_view_modes[$page_id] = $view_mode;

    $vsite->controllers->variable->set('os_search_display_mode', $solr_view_modes);
  }
  else {
    // The vsite controller has logic to prevent saving the default and performs cleanup.
    // This code prevents un-needed vset's when the cache is cleared.
    if (isset($solr_view_modes[$page_id]) && $solr_view_modes[$page_id] == $view_mode) {
      //Already set correctly.
      return;
    }
    // Set View Mode if not set.
    $solr_view_modes[$page_id] = $view_mode;

    variable_set('os_search_display_mode', $solr_view_modes);
  }
}

/**
 * Implements hook_preprocess_search_results().
 */
function os_search_preprocess_search_results(&$variables) {
  if (empty($variables['search_page']['page_id'])) {
    // Not inside a "browse" page.
    return;
  }
  // This will override node results if a node view mode way selected on the
  // apachesolr page configuration page.
  $solr_view_modes = variable_get('os_search_display_mode', array());

  $page_id = $variables['search_page']['page_id'];

  $view_mode = !empty($solr_view_modes[$page_id]) ? $solr_view_modes[$page_id] : 'teaser';

  //Only alter 'search_results' and render node if it is a non-search view mode.
  if (!in_array($view_mode, array('search_result', 'search_index'))){

    // Reset Search Results, we are going to completely override
    $variables['search_results'] = '';

    foreach ($variables['results'] as $result) {
      if ($result['entity_type'] == 'node' && $node = node_load($result['node']->entity_id)) {
        $build = node_view($node, $view_mode);
        // Hide links.
        $build['links']['#access'] = FALSE;
        $variables['search_results'] .= render($build);
      }
    }
  }
}

/**
 * Implements hook_theme_registry_alter().
 *
 * @param $theme_registry
 */
function os_search_theme_registry_alter(&$theme_registry) {
  $path = drupal_get_path('module', 'os_search');
  $theme_registry['search_results']['path'] = $path;
  $theme_registry['search_results']['template'] = 'search-results';
}

function os_search_bundle_selected_form_element($bundle, $default_values) {
  $element = array(
    '#options' => array('all' => 'All vocabularies') + os_search_get_bundle_vocabularies($bundle),
    '#type' => 'checkboxes',
    '#default_value' => $default_values,
    '#multiple' => TRUE,
    '#prefix' => '<div id="vocabularies-div">',
    '#suffix' => '</div>',
    '#title' => 'Select vocabularies',
    //'#states' => array('invisible' => array(':input[name="bundle"]' => array('value' => ""), ), ),
  );
  return $element;
}

function os_search_bundle_selected($form, $form_state) {
  $bundle = $form_state['values']['bundle'];
  $default_value = $form_state['values']['vocabularies'];
  return os_search_bundle_selected_form_element($bundle, $default_value);
}

function os_search_get_bundle_vocabularies($bundle) {
  ctools_include('taxonomy', 'os');
  $taxonomy_vocabularies = os_get_vocabularies_by_bundle('node', $bundle);

  $vocabularies = array();

  if ($taxonomy_vocabularies) {
    foreach ($taxonomy_vocabularies as $taxonomy_vocabulary) {
      $vocabularies[$taxonomy_vocabulary->machine_name] = $taxonomy_vocabulary->name;
    }
  }

  return $vocabularies;
}

/**
 * Implements hook_apachesolr_field_mappings_alter().
 */
function os_search_apachesolr_field_mappings_alter(&$mappings, $entity) {
  $mappings['entityreference']['indexing_callback'] = 'os_search_entityreference_indexing_callback';
}

/**
 * OS search solr indexing for the entity reference field. The "more like this"
 * block functionallity for terms is possible because the term reference
 * indexing function indexed the terms names. We need to index the label of the
 * entity when the entity reference field is referencing to taxonomy terms.
 *
 * @see https://drupal.org/node/2206633
 */
function os_search_entityreference_indexing_callback($entity, $field_name, $index_key, $field_info) {
  $fields = array();
  if (!empty($entity->{$field_name}) && array_key_exists(LANGUAGE_NONE, $entity->$field_name)) {

    // Gets entity type and index key. We need to prefix the ID with the entity
    // type so we know what entity we are dealing with in the mapping callback.
    $entity_type = $field_info['field']['settings']['target_type'];
    $index_key = apachesolr_index_key($field_info);

    // Iterates over all references and adds them to the fields.
    foreach ($entity->{$field_name}[LANGUAGE_NONE] as $reference) {
      if ($id = (!empty($reference['target_id'])) ? $reference['target_id'] : FALSE) {
        $fields[] = array(
          'key' => $index_key,
          'value' => $entity_type . ':' . $id,
        );
      }

      $ids[] = $id;
    }

    if ($entity_type == 'taxonomy_term') {
      // Index the term names into a text field for MLT queries and keyword
      // searching.
      $terms = entity_load($entity_type, $ids);
      foreach ($terms as $term) {
        $vid = $term->vid;

        $fields[] = array(
          'key' => 'tm_vid_' . $vid . '_names',
          'value' => $term->name,
        );
      }
    }
  }

  return $fields;
}

/**
 * Validate handler for the "More like this" block.
 */
function os_search_more_like_this_bundles_element_validate($element, &$form_state) {
  if (!$form_state['values']['results_from_type'] && empty($element['#value'])) {
    form_error($element, t('You must select at least one node type when leaving the related posts checkbox un-checked.'));
  }
}

/**
 * Implements hook_preprocess_page().
 *
 * Adds a link to search settings to the search page's contextual links.
 */
function os_search_preprocess_page(&$variables) {
  $item = menu_get_item();
  $paths = array(
    'search/site',
    'search/site/%',
  );
  if (!in_array($item['path'], $paths)) {
    return;
  }

  $variables['title_suffix']['controls']['section_links']['#links']['settings'] = array(
    'title' => t('Search settings'),
    'href' => 'cp/build/vsite/os-apache-solr-settings',
    'query' => drupal_get_destination(),
  );
}

/**
 * Implements hook_facetapi_widgets().
 */
function os_search_facetapi_widgets() {
  return array(
    'os_search_other_sites_links' => array(
      'handler' => array(
        'label' => t('Links'),
        'class' => 'OsSearchSolrOtherSitesLinks',
        'query types' => array('term', 'date'),
      ),
    ),
  );
}

/**
 * Implements hook_facetapi_facet_info_alter().
 */
function os_search_facetapi_facet_info_alter(array &$facet_info, array $searcher_info) {
  $facet_info['created']['map callback'] = 'os_search_created_facet';
}

/**
 * Change the callback function of the created facet.
 */
function os_search_created_facet(array $values, array $options) {
  $options['format callback'] = 'os_search_facet_time';
  return facetapi_map_date($values, $options);
}

/**
 * Convert the timestamp to string.
 *
 * @param $timestamp
 *  An integer containing the Unix timestamp.
 * @param $gap
 *  Determine the format the timestamp need to be converted to.
 *
 * @return string
 *  The timestamp formatted to a string.
 *
 * @see facetapi_format_timestamp();
 */
function os_search_facet_time($timestamp, $gap) {
  switch ($gap) {
    case FACETAPI_DATE_MONTH:
      return format_date($timestamp, 'custom', 'F Y', 'UTC');

    case FACETAPI_DATE_DAY:
      return format_date($timestamp, 'custom', 'F j, Y', 'UTC');

    case FACETAPI_DATE_HOUR:
      return format_date($timestamp, 'custom', 'g A');

    case FACETAPI_DATE_MINUTE:
      return format_date($timestamp, 'custom', 'g:i A');

    case FACETAPI_DATE_SECOND:
      return format_date($timestamp, 'custom', 'g:i:s A');

    default:
      return format_date($timestamp, 'custom', 'Y', 'UTC');
  }
}

/**
 * Ajax form callback;
 */
function os_search_terms_switch($form, $form_state)  {
  return $form['options']['terms'];
}

/**
 * Ajax form callback;
 */
function os_search_vocabularies_switch($form, $form_state)  {
  return $form['options']['vocab'];
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_search_form_search_block_form_alter(&$form, $form_state) {
  $form['#submit'][] = 'os_search_change_search_path';
}

/**
 * Submit handler; Adding the settings of the search
 */
function os_search_change_search_path($form, $form_state) {
  $box_settings = $form_state['box_settings'];
  $options = array('query' => array('f' => array()));
  $filters = &$options['query'];

  // Collect bundles.
  if ($box_settings['bundle']) {
    $filters['f'][] = 'bundle:' . $box_settings['bundle'];
  }

  // Collect terms.
  if ($box_settings['terms']['terms']) {

    foreach ($box_settings['terms']['terms'] as $term) {
      if (!$term) {
        continue;
      }

      $filters['f'][] = 'sm_og_vocabulary:taxonomy_term:' . $term;
    }
  }

  // Add sort order
  if ($box_settings['sort_property'] != 'relevancy') {
    $filters['solrsort'] = $box_settings['sort_property'] . ' ' . $box_settings['sort_order'];
  }

  // Collect terms.
  _os_search_custom_404_redirect('search/site/' . $form_state['input']['search_block_form'], $options);
}

/**
 * Custom funtion for Search Box
 * 404_page
 */
function _os_search_custom_404_redirect($path = '', array $options = array(), $http_response_code = 302) {
  if ($path === current_path() && empty($options['external']) && url_is_external($path)) {
    // Force url() to generate a non-external URL.
    $options['external'] = FALSE;
  }

  drupal_alter('drupal_goto', $path, $options, $http_response_code);
  // The 'Location' HTTP header must be absolute.
  $options['absolute'] = TRUE;
  $url = url($path, $options);
  header('Location: ' . $url, TRUE, $http_response_code);
  drupal_exit($url);
}

/**
 * Implements hook_forms().
 */
function os_search_forms($form_id, $args) {
  $forms = array();

  if (strpos($form_id, 'os_search_box') === 0) {
    list(, $delta) = explode('___', $form_id);
    $forms[$form_id] = array(
      'callback' => 'os_search_search_box',
      'callback arguments' => array($delta),
    );
  }

  return $forms;
}

/**
 * Form callback; Return the original search box for duplicate search widgets.
 */
function os_search_search_box($form, $form_state) {
  $form = drupal_build_form('search_block_form', $form_state);

  // Removing the original submit handler due to:
  // 1. We don't need it any more. The submit handler will redirect the user to
  // the right place.
  // 2. The submit handler looks for a key that doesn't exists. Removing it will
  // prevent the errors.
  $key = array_search('search_box_form_submit', $form['#submit']);
  unset($form['#submit'][$key]);
  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_search_form_boxes_box_form_alter(&$form, &$form_state) {

  if ($form['plugin_key']['#value'] != 'os_search_search_box') {
    return;
  }

  $form['description']['#prefix'] = '<span class="os-search-solr-widget-description">' . t('Display results based on content type and/or taxonomy.') . '</span>';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_search_os_layout_get_alter($context, &$blocks) {
  // Legacy block replaced with os_search_solr-solr_search_box.
  $blocks = array_filter($blocks, function ($item) {

    if ($item['module'] == 'os_search' && $item['delta'] == 'os_search_box') {
      return FALSE;
    }

    if ($item['delta'] != 'site-search') {
      return TRUE;
    }

    return FALSE;
  });
}

/**
 * Privacy callback for ApacheSolr, for nodes.
 */
function _os_search_privacy_callback($item) {


  $entity_id = $item->nid;
  $entity_type = "node";

  if (!module_exists('vsite')) {
    // We don't have groups.
    return TRUE;
  }

  if (!$entity = entity_load_single($entity_type, $entity_id)) {
    // Entity can't be loaded.
    return FALSE;
  }

  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  $bundle = $wrapper->getBundle();

  if ($entity_type != 'node' || !og_is_group_content_type($entity_type, $bundle)){
    // Entity is not a node, or not a group content.
    return TRUE;
  }

  $gids = $wrapper->{OG_AUDIENCE_FIELD}->value(array('identifier' => TRUE));
  if (!count($gids)) {
    // Entity is not assigned to a group.
    return TRUE;
  }
  $gid = current($gids);
  $group_wrapper = entity_metadata_wrapper('node', $gid);

  if (module_exists('vsite_access') && !empty($group_wrapper->{VSITE_ACCESS_FIELD}) && $group_wrapper->{VSITE_ACCESS_FIELD}->value()) {
    // Private group, and not a private install, exclude it.
    if (variable_get('file_default_scheme', 'public') != 'private') {
      return FALSE;
    }
  }

  $map = features_get_component_map('node');
  if (!$feature = !empty($map[$bundle]) ? reset($map[$bundle]) : NULL) {
    return TRUE;
  }

  $arguments = array(
    ':type' => 'og',
    ':id' => $gid,
    ':otype' => 'variable',
    ':oid' => 'spaces_features',
  );

  $result = db_query("SELECT value FROM {spaces_overrides} WHERE type = :type AND id = :id AND object_type = :otype AND object_id = :oid LIMIT 1", $arguments);

  foreach ($result as $row) {
    $features = unserialize($row->value);
    if (empty($features[$feature]) || $features[$feature] != 1) {
      // Disabled or private feature, flag it.
      return FALSE;
    }
  }

  // If we reached this point, it means the node is 'public'.
  return TRUE;
}

/**
 * Implements hook_search_api_alter_callback_info()
 */
function os_search_search_api_alter_callback_info() {
  $callbacks['os_search_state_alter'] = array(
    'name' => t('Test'),
    'description' => t('Test.'),
    'class' => 'OsSearchStateAlterCallback',
    'weight' => 100,
  );
  
  return $callbacks;
}

function os_search_search_api_index_items_alter(array &$items, SearchApiIndex $index) {

  $fields = $index->options->fields;

  $fields["title"]       = ['type' => 'string'];
  $fields["bundle"]      = ['type' => 'string'];
  $fields["bundle_name"] = ['type' => 'string'];
  $fields["entity_id"]   = ['type' => 'int'];

  $index->update($fields);

  $path = drupal_get_path('module', 'os_search');
  file_put_contents($path . "/logs/index-1.log", json_encode($index, true));
  file_put_contents($path . "/logs/items-1.log", json_encode($items, true));
}

/**
 * @file
 * Search API data alteration callback that adds the workflow state info to the entity.
 */

class OsSearchStateAlterCallback extends SearchApiAbstractAlterCallback {
  
  public function alterItems(array &$items) {

    $path = drupal_get_path('module', 'os_search');
    file_put_contents($path . "/logs/alterItems.log", json_encode($items, true));

    foreach ($items as $id => &$item) {
      $item->bundle = $item->type;
      $item->bundle_name = self::entity_bundle_label("node", $item->type);
      $item->entity_id = $id;
      $item->entity_type = "node";
    }
  }

  public function propertyInfo() {
    return array(
      'title' => ['type' => 'string', 'label' => 'Title', 'description' => 'Test'],
      'entity_type' => ['type' => 'string', 'label' => 'Title', 'description' => 'Test'],
      'entity_id' => ['type' => 'int', 'label' => 'Title', 'description' => 'Test'],
      'bundle_name' => ['type' => 'string', 'label' => 'Title', 'description' => 'Test'],
      'language' => ['type' => 'string', 'label' => 'Title', 'description' => 'Test'],
    );
  }

  public static function entity_bundle_label($entity_type, $bundle_name) {
    $labels = &drupal_static(__FUNCTION__, array());
  
    if (empty($labels)) {
      foreach (entity_get_info() as $type => $info) {
        foreach ($info['bundles'] as $bundle => $bundle_info) {
          $labels[$type][$bundle] = !empty($bundle_info['label']) ? $bundle_info['label'] : FALSE;
        }
      }
    }
  
    return $labels[$entity_type][$bundle_name];
  }
}
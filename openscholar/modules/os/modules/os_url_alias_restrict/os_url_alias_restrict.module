<?php

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node form.
 */
function url_alias_restrict_form_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = 'url_alias_restrict_url_alias_validate';
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for term form.
 */
function url_alias_restrict_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = 'url_alias_restrict_url_alias_taxonomy_validate';
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for vocabulary form.
 */
function url_alias_restrict_form_taxonomy_form_vocabulary_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = 'url_alias_restrict_url_alias_taxonomy_validate';
}

/**
 * Implements hook_pathauto_alias_alter().
 */
function url_alias_restrict_pathauto_alias_alter(&$alias, array &$context) {
  $vsite = vsite_get_vsite();
  $purl = $vsite->group->purl;
  // For vocabulary form
  if ($context['module'] == 'taxonomy_vocabulary') {
    $purl_vocab = $purl . '/' .'vocab';
    $path_alias = substr($alias, strlen($purl_vocab) + 1);
  }
  //For term form
  else if ($context['module'] == 'taxonomy_term') {
    $vocab = $context['data']['term']->vocabulary_machine_name;
    $purl_vocab = $purl . '/' . $vocab;
    $path_alias = substr($alias, strlen($purl_vocab) + 1);
  }
  // For node form
  else {
    $path_alias = substr($alias, strlen($purl) + 1);
  }
  if (url_alias_restrict_is_reserved($path_alias)) {
    $alias = $alias . '-' . 0;
  }
  return $alias;
}

/**
 * Node form validation handler for URL alias form element.
 */
function url_alias_restrict_url_alias_validate($form, &$form_state) {
  if (!empty($form_state['values']['path']['alias'])) {
    $alias = trim($form_state['values']['path']['alias']);
    if (url_alias_restrict_is_reserved($alias)) {
      $form_state['values']['path']['alias'] = $alias . '-' . 0;
    }
  }
}

/**
 * Taxonomy & Term form validation handler for URL alias form element.
 */
function url_alias_restrict_url_alias_taxonomy_validate($form, &$form_state) {
  if (!empty($form_state['values']['path']['alias'])) {
    $alias = trim($form_state['values']['path']['alias']);
    // getting the path for the vocabulary form
    if(strpos($alias, "vocab") === 0) {
      $path = substr($alias, strlen('vocab') + 1);
    }
    // getting the path for the term form
    else if ($form_state['values']['form_id'] == 'taxonomy_form_term') {
      $vocab = $form_state['values']['vocabulary_machine_name'];
      if (strpos($alias, $vocab) === 0) {
        $path = substr($alias, strlen($vocab) + 1);
      }
      else {
        $split_path = explode('/', $alias);
        $path = end($split_path);
      }
    }
    // getting the path for the node form
    else {
      $path = $alias;
    }
    if (url_alias_restrict_is_reserved($path)) {
      $form_state['values']['path']['alias'] = $alias . '-' . 0;
    }
  }
}
/**
 * Determine whether a path is reserved.
 *
 * Users cannot create a URL alias which is reserved.
 *
 * By default, paths are considered to be non-reserved. If a path does not
 * match any of the patterns in path_get_reserved_paths(), or if it matches
 * both reserved and non-reserved patterns, it is considered non-reserved.
 *
 * @param $path
 *   A Drupal path.
 *
 * @return
 *   TRUE if the path is reserved, FALSE otherwise.
 *
 * @see path_get_reserved_paths()
 * @see hook_reserved_paths()
 * @see hook_reserved_paths_alter()
 */
function url_alias_restrict_is_reserved($path) {
  $path_map = &drupal_static(__FUNCTION__);
  if (!isset($path_map['reserved'][$path])) {
    $patterns = url_alias_restrict_get_reserved_paths();
    $path_map['reserved'][$path] = drupal_match_path($path, $patterns['reserved']);
    $path_map['non_reserved'][$path] = drupal_match_path($path, $patterns['non_reserved']);
  }
  return $path_map['reserved'][$path] && !$path_map['non_reserved'][$path];
}

/**
 * Get a list of reserved and non-reserved paths.
 *
 * @return array
 *   An associative array containing the following keys:
 *   - 'reserved': An array of reserved paths and regular expressions in a
 *      format suitable for drupal_match_path().
 *   - 'non_reserved': An array of non-reserved paths and regular expressions.
 *
 * @see hook_reserved_paths()
 * @see hook_reserved_paths_alter()
 */
function url_alias_restrict_get_reserved_paths() {
  $patterns = &drupal_static(__FUNCTION__);
  if (!isset($patterns)) {
    $paths = module_invoke_all('reserved_paths');
    drupal_alter('reserved_paths', $paths);
    // Combine all reserved paths into one array, and likewise for
    // non-reserved paths, for easier handling.
    $patterns = array();
    $patterns['reserved'] = array();
    $patterns['non_reserved'] = array();
    foreach ($paths as $path => $enabled) {
      if ($enabled) {
        $patterns['reserved'][] = $path;
      }
      else {
        $patterns['non_reserved'][] = $path;
      }
    }
    $patterns['reserved'] = implode("\n", $patterns['reserved']);
    $patterns['non_reserved'] = implode("\n", $patterns['non_reserved']);
  }
  return $patterns;
}

/**
 * Implements hook_reserved_paths().
 *
 * Provide core reserved paths.
 */
function url_alias_restrict_reserved_paths() {
  $paths = array(
    'node' => TRUE,
    'node/*' => TRUE,
    'user' => TRUE,
    'user/*' => TRUE,
    'admin' => TRUE,
    'admin/*' => TRUE,
    'themes' => TRUE,
    'modules' => TRUE,
    'tag' => TRUE,
    'root' => TRUE,
    'repository' => TRUE,
  );
  return $paths;
}